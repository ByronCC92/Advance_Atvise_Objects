<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<svg height="800" version="1.2" width="1680" xmlns="http://www.w3.org/2000/svg" xmlns:atv="http://webmi.atvise.com/2007/svgext" xmlns:xlink="http://www.w3.org/1999/xlink">
 <defs/>
 <metadata>
  <atv:parameter behavior="optional" defaultvalue="" desc="Global Geolocation List" name="Global_Geo_List" valuetype="global"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Global_Geo_Address" name="Global_Geo_Address" valuetype="string"/>
  <atv:parameter behavior="optional" desc="Geo Config" name="Geo_Config" valuetype="address"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Iframe to Open" name="Iframe" valuetype="string"/>
  <atv:parameter behavior="optional" defaultvalue="" desc="Trigger Name" name="Trigger_Name" valuetype="string"/>
  <atv:gridconfig enabled="true" gridstyle="lines" height="20" width="20"/>
  <atv:snapconfig enabled="true" height="10" width="10"/>
 </metadata>
 <foreignObject height="800" id="map_canvas" width="1680" x="0" y="0">
  <div style="width:100%;height:100%" xmlns="http://www.w3.org/1999/xhtml"/>
 </foreignObject>
 <rect atv:refpx="840" atv:refpy="400" fill="none" height="800" id="border" stroke="#000000" stroke-width="2" width="1680" x="0" y="0"/>
 <text atv:refpx="705.5" atv:refpy="413" fill="none" font-family="Arial" font-size="48" id="label" x="660" y="417.5">Geolocation Map</text>
 <script atv:desc="" atv:name="" type="text/ecmascript"><![CDATA[//External Variables
var Iframe=webMI.query["Iframe"];
var Trigger_Name=webMI.query["Trigger_Name"];
var Global_Geo_List;
var Global_Geo_ListI={};
var Global_Geo_ListII=webMI.query["Global_Geo_List"];
var Geo_Config=webMI.query["Geo_Config"];
var Global_Geo_Address=webMI.query["Global_Geo_Address"];


//Internal Variables
var google = webMI.rootWindow.google;
var map; //Map Global Map
var markers  =  new Array();
var icon = "/atvise_Advanced_Objects_Geo_Icons/Map_Blue.png";
var markerWidth;
var markerHeight;
var Current_Zoom=14;
var Current_Lat; //Pointer_Lat
var Current_Lng; //Pointer_Lon
var Point_fixed=false;
var mapCanvas=document.getElementById("map_canvas");
var mapBorder=document.getElementById("border");
var SVGScaleX;
var SVGScaleY;
var OffsetX;
var OffsetY;
var Simulated_Click=false;

//Initial Conditions
webMI.addOnload(function() {
	
	//Hide  
	webMI.gfx.setVisible("label", false); 
	webMI.gfx.setVisible("border", false);
	webMI.gfx.setScaledEvents(mapCanvas);
	
	console.log("Global_Geo_Address");	
	console.log(Global_Geo_Address);
	
	//Get Screen info
	const BouningInfo = mapCanvas.getBoundingClientRect();
	const Offsets=calculateOffsetsFromRect(BouningInfo);
	OffsetX=Offsets.OffsetX;
	OffsetY=Offsets.OffsetY;
	//OffsetX=0.0048;
	//OffsetY=0.00058;
	console.log("BouningInfo");
	console.log(BouningInfo);
	var SVGScaling=extractScaling(mapBorder);
	SVGScaleX=SVGScaling.scaleX;
	SVGScaleY=SVGScaling.scaleY;
	
	//Initialize Map
	InitializeMap();
	
	//Update Map
	(async () => {
		 await waitForCondition();
		  updateMap();
	})();

	

	
});	

//-------------------Trigger Section--------------------//

//Update Map
webMI.trigger.connect("update_map_"+Trigger_Name, function (e) {
	//Update Map
	updateMap();
});



//-------------------Functions Section--------------------//

//Initialize map
function InitializeMap(){
	//Read the Global_List_Address
	webMI.data.read(Global_Geo_Address, function(e) {
	
	   //Process Result
	   var result=e.value;
	   Global_Geo_List=result.map((x) => JSON.parse('{' + x + '}'));
	   for(var i=0;i<Global_Geo_List.length;i++){
			Global_Geo_ListI[i]=Global_Geo_List[i][i];
	   }
	   
		//Calculate center
		var CenterI=calculateCenter(Global_Geo_ListI);
		var Center=new google.maps.LatLng(Number(CenterI.averageLatitude),Number(CenterI.averageLongitude));

		//Initialize Map
		var myOptions = {
			zoom: Current_Zoom,
			center: Center,
			mapTypeId: google.maps.MapTypeId.SATELLITE
		
		};
	    map = new google.maps.Map(mapCanvas, myOptions);
	    
	    //Idle Behavior
		google.maps.event.addListenerOnce(map, 'idle', function() {
			google.maps.event.trigger(map, 'resize');
			map.setCenter(Center);
		});
		
		
		//--------Listeners--------//
		
		//Mouse movement
		map.addListener('mousemove', (event) => {
			if(!Point_fixed) { //if it is false
				// Get the current latitude and longitude of the mouse pointer
				Current_Lat = event.latLng.lat();
				Current_Lng = event.latLng.lng();
				var Update_text={ "2 Latitude":Current_Lat, "3 Longitude":Current_Lng};
				updateSelectionText(Update_text);
			}

		});
						
		// Mouse click
		map.addListener("click", (mapsMouseEvent) => {
			console.log("mapCanvas");
			console.log(mapCanvas);
			console.log("Scaling");
			console.log(extractScaling(mapBorder));
			var ScreenCTM=webMI.gfx.getScreenCTM("map_canvas");	
			console.log(ScreenCTM);			
			console.log(mapsMouseEvent);
			var ScaleX=ScreenCTM.a;
			var ScaleY=ScreenCTM.d;
			var eventInfo=mapsMouseEvent.pixel;
			var myMoveAreaOffsetLeft = webMI.gfx.getAbsoluteOffset("left", true, mapCanvas);
		    var myMoveAreaOffsetTop = webMI.gfx.getAbsoluteOffset("top", true, mapCanvas);

			console.log("myMoveAreaOffsetLeft: "+myMoveAreaOffsetLeft);			
			console.log("myMoveAreaOffsetTop: "+myMoveAreaOffsetTop);
			var projection = map.getProjection();
			
			
			//0,5333198078455784
			
			//var position = new google.maps.LatLng(Current_Lat,Current_Lng);
			const clickedLatLong = mapsMouseEvent.latLng;
			//console.log("Clicked Lat: "+clickedLatLong.lat());
			//console.log("Clicked Long: "+clickedLatLong.lng());
			//Pixel coordinate location projected
			var point = projection.fromLatLngToPoint(clickedLatLong);
			//console.log(point);
			//var OffsetY = ((-0.2209*Math.pow(ScaleY, 3))+(0.3503*Math.pow(ScaleY, 2))+(-0.1962*ScaleY)+ 0.0399)*SVGScaleY;
						
			//var OffsetX = (0.041501)*SVGScaleX;
			//var OffsetX = (0.0042)/*/SVGScaleX*/;
			console.log("Pixel OffsetY: "+OffsetY);
			console.log("Pixel OffsetX: "+OffsetX);
			//New Pixel coordinate 
			var pointcalc = new google.maps.Point(Number(point.x)+Number(OffsetX), Number(point.y)+Number(OffsetY));
			//console.log("pointcalc");				
			//console.log(pointcalc);
			
			//New Latitude and Longitude
			var latLng = projection.fromPointToLatLng(pointcalc);
			//console.log(latLng);
			
			//console.log("Calculated Lat: "+latLng.lat());
			//console.log("Calculated Long: "+latLng.lng());
			
			var marker = new google.maps.Marker({
				position: latLng,
				map: map,
				title: "Test",
				icon:{
					url: icon,
					scaledSize: new google.maps.Size(markerWidth, markerHeight)
				}
			});			
			
		});
	});
}

//Update map
function updateMap(){

	//---------------Re-initialize markers
	
	//Remove all the Makers
	for (var i=0; i<markers.length; i++){
			removeMarker(markers,i);
	}
	
	//Remove markers
	markers=[];
	markers.length = 0;
	Global_Geo_ListI=[];
	
	//------------Read the Global_List_Address
	webMI.data.read(Global_Geo_Address, function(e) {
	
	   //Read data 
	   var result=e.value;
	   
	   //Process Result
	   Global_Geo_List=result.map((x) => JSON.parse('{' + x + '}'));
	   for(var i=0;i<Global_Geo_List.length;i++){
			Global_Geo_ListI[i]=Global_Geo_List[i][i]; //Get array of objects with each geo point
	   }
				
		//Create Markers
		var zoom = map.getZoom();
		markerWidth=(zoom/5)*20;
		markerHeight=(zoom/5)*20;
		
		setTimeout(function(){
			 for (const key in Global_Geo_ListI) {
				if (Global_Geo_ListI.hasOwnProperty(key)) {
					const obj = Global_Geo_ListI[key];
						console.log("Adding: ");
						console.log(obj);
						addMarker(map,obj);
					
				}
			}
			
			
			//Fit map to Markers
			fitMapToMarkers(map, markers);

		},200);
		
		//Add Listener for resizing
		google.maps.event.addListener(map, 'zoom_changed', function() {
	
			var zoom = map.getZoom();
			markerWidth = (zoom/5)*20
			markerHeight = (zoom/5)*20
		
			//set the icon with the new size to the marker
			for (var i=0; i<markers.length; i++){
				markers[i].setIcon({
					url: icon,
					scaledSize: new google.maps.Size(markerWidth, markerHeight)
				});
			}
		});
		
	});
}

//Calculate Center
function calculateCenter(data) {
    let totalLatitude = 0;
    let totalLongitude = 0;
    let count = 0;

    for (const key in data) {
        if (data.hasOwnProperty(key)) {
            const obj = data[key];
            // Use the explicit key names
            if(obj['2 Latitude'] !== undefined && obj['3 Longitude'] !== undefined) {
                totalLatitude += Number(obj['2 Latitude']);
                totalLongitude += Number(obj['3 Longitude']);
                count++;
            }
        }
    }

    if (count === 0) {
        // Return null or some default value if no valid coordinates are found
        return null;
    }

    const averageLatitude = totalLatitude / count;
    const averageLongitude = totalLongitude / count;

    return { averageLatitude, averageLongitude };
}


//Create Marker
function addMarker(map,obj) {

	var position = new google.maps.LatLng(Number(obj['2 Latitude']), Number(obj['3 Longitude']));
	
	var marker = new google.maps.Marker({
		position: position,
		map: map,
		title: obj['1 Name'],
		icon:{
			url: icon,
			scaledSize: new google.maps.Size(markerWidth, markerHeight)
		}
	});
	
	//Add to markers list
	markers.push(marker);
	
	//Add Listeners
	marker.addListener("click", function(e){
		webMI.display.openDisplay(obj['5 Display'], webMI.query, Iframe);
	});
	
}

//Remove markers from the map
function removeMarker(markers,remove_Index){
	//Remove from the map
	markers[remove_Index].setMap(null);

}

//Set myOptions
function setMapOptions(map){
	
	//Initialize Map
		var myOptions = {
			zoom: Current_Zoom,
			center: Center,
			mapTypeId: google.maps.MapTypeId.SATELLITE
		
		};
		
		//Update Options
		map.setOptions(myOptions);
}

//Update selection
function updateSelectionText(New_Values){
	webMI.trigger.fire("write_value_Global_List_Input", New_Values);
}


//Fit map in Markers
function fitMapToMarkers(map, markers) {
    var bounds = new google.maps.LatLngBounds();

    // Extend the bounds to include each marker's position
    markers.forEach(function(marker) {
        bounds.extend(marker.getPosition());
    });
	
    // Adjust the map view to fit the bounds that encompass all markers
    map.fitBounds(bounds);
    Current_Zoom=map.getZoom(); //Map Zoom at the moment to keep it Center
}



//Wait for data to be ready

function waitForCondition() {
  return new Promise((resolve) => {
    const interval = setInterval(() => {
	var condition=(map!=undefined);
      if (condition) {
        clearInterval(interval);
        resolve(true);
      }
    }, 100);
  });
}

function waitForCondition2() {
  return new Promise((resolve) => {
    const interval = setInterval(() => {
	var condition=(markers.length>=Global_Geo_ListI.length);
      if (condition) {
        clearInterval(interval);
        resolve(true);
      }
    }, 100);
  });
}


function extractScaling(element) {
    while (element) {
        // Check if the element has a 'transform' attribute
        if (element.hasAttribute('transform')) {
            // Get the value of the 'transform' attribute
            const transformValue = element.getAttribute('transform');

            // Extract the scale values from the transformation matrix
            // The matrix is in the form matrix(scaleX, 0, 0, scaleY, translateX, translateY)
            const matches = transformValue.match(/matrix\(([\d.]+),\s*0,\s*0,\s*([\d.]+),\s*[\d.]+,\s*[\d.]+\)/);

            if (matches && matches.length === 3) {
                // Convert the scale values to numbers and return them
                return {
                    scaleX: parseFloat(matches[1]),
                    scaleY: parseFloat(matches[2])
                };
            }
        }
		console.log(element);
        // Move up to the parent element
        element = element.parentElement;
    }

    // Return default scaling of 1 for both X and Y if no transform attribute is found
    return {
        scaleX: 1,
        scaleY: 1
    };
}

function calculateOffsetsFromRect(rect) {
    // Updated coefficients for Ridge regression of OffsetX
    const interceptX = -0.8024766723788219;
    const coefX = [
        1.93740491e-09, 8.80248048e-10, 1.51401482e-11,
        3.10572002e-09, -1.12435557e-07, -1.22027697e-07, 1.32285208e-06,
        -1.00147627e-06, -1.76946867e-06, 6.01915072e-07, 4.58462812e-07,
        2.05933102e-08, 2.12380349e-06, -7.10688213e-07
    ];

    // Updated coefficients for Ridge regression of OffsetY
    const interceptY = -0.26043481006360814;
    const coefY = [
        5.99731166e-10, 2.99584170e-10, 4.92019568e-12,
        1.01124106e-09, -3.28567109e-08, -5.04456162e-08, 4.09572508e-07,
        -3.12887771e-07, -5.71376265e-07, 2.04806454e-07, 1.63717421e-07,
        6.69234643e-09, 6.91516146e-07, -2.34730215e-07
    ];

    // Extract the properties from the DOMRect object
    const { left: X, top: Y, width: Width, height: Height } = rect;

    // Manually calculate the polynomial features up to degree 2
    const features = [
        1, X, Y, Width, Height,  // degree 1
        X*X, X*Y, X*Width, X*Height,  // degree 2 interactions
        Y*Y, Y*Width, Y*Height,
        Width*Width, Width*Height,
        Height*Height
    ];

    // Calculate OffsetX using the polynomial features and updated Ridge regression coefficients
    let OffsetX = interceptX;
    for (let i = 1; i < features.length; i++) {  // Start from 1 to skip the first term (intercept)
        OffsetX += coefX[i-1] * features[i];
    }

    // Calculate OffsetY using the polynomial features and updated Ridge regression coefficients
    let OffsetY = interceptY;
    for (let i = 1; i < features.length; i++) {  // Start from 1 to skip the first term (intercept)
        OffsetY += coefY[i-1] * features[i];
    }

    return { OffsetX, OffsetY };
}


webMI.addEvent("map_canvas", "click", function(e) {

			
	console.log("Foreing x: "+e.clientX);			
	console.log("Forieng Y: "+e.clientY);
});

]]></script>
</svg>
